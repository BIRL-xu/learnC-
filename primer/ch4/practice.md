####　求值顺序的潜在风险：对于哪些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。
````c++
int i = 0;
cout << i << " " << ++i << endl; // 未定义。
// 编译器可能先求++i的值再求i的值，此时输出1 1;
// 也可能先求i的值再求++i的值，输出结果0 1;
// 该输出表达式的行为是未知的。

auto i = f() + g()*h() + j();
// 1. 如果几个函数无关，它们既不会改变同一个对象的状态也不执行IO任务，那么函数的调用顺序不受限制；
// 2. 如果其中几个函数影响同一个对象，则它是一条错误的表达式，将产生未定义行为。
````
#### 取余运算： m%n的结果符号值匹配m的符号，即m%(-n) = m%n, (-m)%n = -(m%n).C++11新标准规定商一律向0取整(直接切除小数部分).
#### Q4.4: 在下面的表达式中添加括号，说明其求值的过程和最终结果。编写程序编译该表达式并输出其结果验证之前的推断。
````c++
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2;

// ((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2);
````
#### A: 见4-4.cpp。
#### Q4.5: 写出一条表达式用于确定一个整数是奇数还是偶数。
#### A: 
````c++
int a = 4;
bool isEvenNumber = (a % 2) == 0;
````
#### Q4.8: 说明在逻辑与、逻辑或及相等性运算中运算对象求值的顺序。
#### A:从左至右。
#### Q4.9: 解释在下面的if语句中条件部分的判断过程
````c++
const char *cp = "Hello World";
if(cp && *cp) 
// 先判断cp指针本身是否为空指针，如果为空，整个条件表达式为假。
// 如果cp为非空指针，进一步判断cp所指向字符串是否为空字符串;
// 如果为空字符串，则整个条件表达式为假；否则，为真。
````
#### Q4.10: 为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。
#### A:
````c++
int a = 0;
while((std::cin >> a) && (a != 42));
````
#### Q4.11: 书写一个表达式用于测试4个值a, b, c, d的关系，确保a大于b、　ｂ大于ｃ、ｃ大于ｄ。
#### A: `a > b && b > c && c > d`
#### Q4.12: 假设ｉ、ｊ、ｋ是三个整数，说明表达式 `i!=j<k`的含义。
#### A: 先判断j和k的大小关系，再判断ｉ是０还是１．
#### Q4.13: 在下述语句中，当赋值完成后i和d的值分别是多少？
````c++
int i; double d;
d = i = 3.5; // d = 3.0, i = 3.
i = d = 3.5; // d = 3.5, i = 3;
````
#### Q4.14: 执行下述if语句后将发生什么情况？
````c++
if(42 = i) // 编译错误
if(i = 42) // 先赋值42个ｉ再判断条件是否为真，所以if条件为真。
````
#### Q4.15: 下面的赋值是非法的，为什么？应该如何修改？
````c++
double dval; int ival; int *pi;
dval = ival = pi = 0; // pi是int型指针，不能给int型的ival赋值。
// 修改为
pi = ival = dval = 0;
````
#### Q4.16:　尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？
````c++
if(p = getPtr() != 0) // 预习目的是判断getPtr()函数返回给p的指针是否为空
// 但因为赋值语句优先级比条件语句优先级低，所以先判断条件语句，函数返回的指针是否为空，将判断结果赋值给p。
// 如果为假，可以赋值给指针p，如果为真，１不能赋值给指针，导致错误.
// 修改为：
if((p = getPtr) != 0)

if(i = 1024) // 预期目的是判断i是否等于1024。但现在是将1024赋值给i，导致if条件为真。
````
#### 解引用与后置递增运算符的组合使用: 迭代器或指针访问元素
````c++
auto pbeg = v.begin();
while(pbeg != v.end())
    cout << *pbeg++ << endl;
// 如果使用前置版本*++opbeg将导致跳过第一个元素，甚至会解引用end()的返回迭代器，导致程序出错。
````
#### Q4.17: 说明前置递增运算符和后置递增运算符的区别。
#### A: 前置递增运算符先将运算对象加１后再使用，而后置递增运算符是先使用运算对象再加１。
#### Q4.1９：　假设ptr的类型是指向int的指针，vec的类型是vector<int>、ival的类型是int,说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？
````c++
ptr != 0 && *ptr++ // 判断ptr是否为空指针且它当前所指向的值是否为真，然后ptr递增。
ival++ && ival; // 判断ival和
vec[ival++] <= vel[ival]; // 判断vec中相邻两个元素是否相等；但使用后置递增会导致一直判断同一个位置的元素。
// 修改为vec[++ival] <= vel[ival].
````
#### Q4.20: 假设iter的类型是vector<string>::iterator, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？
````c++
*iter++; //　合法：解引用当前迭代器，并将迭代器前移一位。
(*iter)++; // 合法：含义同上。
*iter.empty(); // 错误：　该表达式导致iter通过点运算符访问函数empty().因为点运算符的优先级高于解引用运算符。
iter->empty(); // 合法：通过迭代器用指针运算符访问成员函数empty()。
++*iter; // 错误：先解引用迭代器得到字符串元素，然后加１，字符串不能使用递增运算符。
iter++->enpty(); // 错误：C++不支持运算符这样组合使用。
````
#### Q4.21: 编写一段程序，使用条件运算符从vector<int>中找到哪些元素的值是奇数，然后将这些奇数值翻倍。
#### A:见4-21.cpp。
#### Q4.22: 本节的示例程序将成绩划分成highpass、pass和fail三种，扩展该程序是其进一步将60分到75分之间的成绩设定为lowpass。要求程序包含两个版本：一个版本只使用条件运算符；另外一个版本使用ｉｆ语句。哪个版本的程序更容易理解呢？为什么？
#### A:　见4-22.cpp。 if-else语句更容易理解，因为符合人的基本逻辑。
#### Q4.23: 因为运算符的优先级问题，下面这条表达式无法通过编译。根据4.12节中的表(第１４７页)指出它的问题在哪里？应该如何修改？
````c++
string s = "word";
string p1 = s + s[s.size()-1] == 's' ? "" : "s"; // s + s[s.size()-1]的结果是string类型，只能和string类型比较。
// 将字符's'修改为字符串"s"
string p1 = s + s[s.size()-1] == "s" ? "" : "s";
````
#### sizeof是一个运算符，不是函数.返回一个表达式或一个类型名字所占的字节数，满足右结合律，返回类型是size_t。
````c++
Sales_data data, *p;
sizeof(Sales_data); // 存储Sales_data类型的对象所占的空间大小。
sizeof data; // data的类型的大小，即sizeof(Sales_data);
sizeof p; // 指针所占空间的大小
sizeof *p; // 因右结合律，等价于sizeof (*p). p所指类型的空间大小，即sizeof(Sales_data);
sizeof data.revenue; // Sales_data的revenue成员对应类型的大小。
sizeof Sales_data::revenue; // Sales_data的revenue成员对应类型的大小。
````
#### sizof运算符计算数组大小
````c++
int a[] = {0, 1, 2};
constexpr size_t sz = sizeof(a)/sizof(*a);
````
#### Q4.28: 编写一段程序，输出每一种内置类型所占空间的大小。
#### A: 见4-28.cpp。
#### Q4.29: 推断下面代码的输出结果并说明理由。实际运行这段程序，结果和你想象的一样吗？如果不一样，为什么？
````c++
int x[10]; int *p = x;
cout << sizeof(x)/sizeof(*x) << endl; // 输出数组大小10.
// 在32位计算机上输出１：　因为sizeof(p)是int型指针所占空间大小，为４个字节; sizeof(*p)为int型数据占４个字节，因此输出为１．
// 在64为计算机上输出２: 因为sizeof(p)是int型指针所占空间大小，为8个字节; sizeof(*p)为int型数据占４个字节，因此输出为１．
cout << sizeof(p)/sizeof(*p) << endl;
````
#### Q4.31: for循环中前置递增和后置递增的区别：
* 后置类型需要开辟一个临时对象空间来保存递增后的值，然后在拷贝赋值给运算对象，效率较低；
* 对内置类型来说，效率差异可以忽略不计；但对于一些自定义类型，如果对象较大，效率差异不可忽略。因此，推荐使用前置递增。
#### Q4.32: 解释下面这个循环的含义。
````c++
// 同时使用指针和下标的方式遍历数组。
constexpr int size = 5;
int ia[size] = {1, 2, 3, 4, 5};
for(int *ptr = ia, ix = 0;
ix != size && ptr != ia+size; ++ix, ++ptr){/**/}
````
#### `const_cast`只能改变运算对象的底层const, 一般用于有函数重载的上下文中。
````c++
const char *pc;
char *p = const_cast<char*>(pc);// 正确：但是通过p写值是未定义的行为。
````
#### Q4.37: 用命名的强制类型转换改写下列旧式的转换语句。
````c++
int i; double d; const string *ps; char *pc; void *pv;
pv = (void*)ps;// pv = static_cast<void*>ps;
i = int(*pc); // i = static_cast<int>(*pc);
pv = &d; // pv = static_cast<void*>(&d);
pc = (char*)pv; // pc = static_cast<char*>pv;

````