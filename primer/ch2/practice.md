#### Q2.1 类型int、long、long long和short的区别是什么？无符号类型和带符号类型的区别是什么？float和double的区别是什么？
#### A: short是整型中最小的，它们可表示的位数关系为：short <= int <= long <= long long。
#### Q2.2: 计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你的理由。
#### A: 都是用double类型，因为利率、本金和付款都可能是浮点数，而float型和double型的计算代价相差无几，但double可表示更多的有效位，多余任何金额单位都适用。
#### 经典错误1： 无符号整型作为循环条件时，容易造成死循环（带符号类型会自动转换为无符号类型），如：
````c++
// 变量u永远不会小于0，循环条件一直成立。
// 当u等于0时，进入循环输出u为0，然后执行--u；
// 但u是无符号整型，会将-1转换为符号整型，如果
// unsigned int 是32位的，结果为4294967295，
// 仍然大于0。
for(unsigned int u = 10; u >= 0; --u)
{
    std::cout << u << std::endl;    
}
````
#### Q2.3＆Ｑ2.4:　读程序写结果。编写程序验证你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。
````c++
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl; // 32
    std::cout << u - u2 << std::endl; // 4294967264；-32被转换为无符号型。

    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl; // 32
    std::cout << i - i2 << std::endl; // -32
    std::cout << i - u << std::endl;  // 0；10被转换为无符号型还是10。
    std::cout << u - i << std::endl;  // 0
````
* 代码见2.4.cpp，输出：
````
32
4294967264
32
-32
0
0
````
#### Q2.8: 请利用转义字符序列编写一段程序，要求先输出2M,然后转到新一行。修改程序使其先输出２，然后输出制表符，再输出Ｍ，最后转到新一行。
#### A:代码如下：
````
#include <iostream>

int main()
{
    std::cout << "2\115\n";
    std::cout << "2\t\115\n";
    return 0;
}
````
*　输出:
````
2M
2	M
````
#### 默认初始化：定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定。
#### Q2.9: 解释下列定义的含义。对于非法的定义，请说明错在何处并将其改正。
````c++
std::cin >> int input_value; // 不能使用时进行声明
//修改为
int input_value;
std::cin >> input_value;

int i = {3.14}; // 错误：转换未执行，因为存在丢失信息的危险
// 修改为
int i = (3.14);

double salary = wage = 999.99; //　可以
int i = 3.14; // 可以，但会丢失小数点后的数值。
````
#### C++语言支出分离式机制，即声明和定义区分开。
* 声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
* 定义负责创建与名字关联的实体，申请存储空间，有时会为变量赋一个初始值。
* 只声明不定义变量：
````c++
extern int i; // 只声明
extern int i = 10; // 声明且定义
````
* 声明并定义变量:
````c++
int j;
````
* 变量只能被定义一次，但是可以被多次声明。
* 声明和定义的区别的使用场景：一个变量要在多个文件中使用时，只能在其中一个文件内定义，其他用到该变量的文件都必须进行声明。
#### Q2.11: 指出下面的语句是声明还是定义。
````c++
extern int ix = 1024; // 声明和定义
int iy; // 声明和定义
extern int iz; // 只声明
````
#### Q2.12: 请指出下面的名字中那些是非法的？
````c++
int double = 3.14; // 非法, double为Ｃ++关键字
int _; // 合法
int catch-22; // 字符‘-’非法
int 1_or_2 = 1; // 合法
double Double = 3.14; // 合法
````
#### Q2.13: 下面程序中j的值是多少？
````c++
int i = 42;
int main()
{
    int i = 100;
    int j = i;
}
````
#### A: i被main内部的局部变量覆盖，所以j等于100．
#### Q2.14: 下面的程序合法吗？如果合法，它将输出多少？
````c++
int i = 100, sum = 0;
for(int i = 0; i != 10; ++i)
    sum += i;
std::cout << i << " " << sum << std::endl;
````
#### A: 输出`100 45`；for循环中使用局部作用域的i,因此sum等于０到９的和；std::cout使用的是全局变量的i，因此输出100.
#### Q2.15: 下面的哪个定义是不合法的？为什么？
````c++
int ival = 1.01; // 合法
int &rval1 = 1.01; // 不合法，引用只能绑定到对象上，不能与字面值绑定
int &rval2 = ival; // 合法，绑定到同一种数据类型
int &rval3; // 不合法，引用必须被初始化
````
#### Ｑ2.16:检查下面的所有赋值然后回答：哪些赋值是不合法的?为什么？哪些赋值是合法的？他们执行了什么样的操作？
````c++
int i = 0, &r1 = i;
double d = 0, &r2 = d;

r2 = 3.14159; // 合法
r2 = r1; // 合法
i = r2; // 合法
r1 = d; // 合法
````
#### Q2.17: 执行下面的代码段将输出什么结果？
````c++
int i, &ri = i;
i = 5; ri = 10;
std::cout << i << " " << ri << std::endl; // 输出10 10.
````
#### Q2.18:　编写代码分别更改指针的值以及指针所指对象的值。
#### A:
````
int i = 10;
int j = 100;
int *p = &i; // p保存着i的地址
p = &j; // 改变指针的值，现在p保存着j的地址
*p = i; //　改变指针p所值对象的值，由100变为10
````
#### Q2.19: 说明指针和引用的主要区别。
#### A:
* 都实现了对其他对象的间接访问
* 指针本身就是一个对象，允许赋值和拷贝
* 指针在声明周期内可只想不同的对象
* 指针在定义时编译器不要求必须初始化(但强烈建议始终初始化)
* 引用一旦定义，就只能绑定到一个对象上，不能更改。
#### Q2.20: 请叙述下面这段代码的作用。
````c++
int i = 42;
int *p1 = &i;
*p1 = *p1 * *p1;
````
#### A: 这段代码实现了求i的平方的功能，即42*42。
#### Q2.21: 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？
````c++
int i = 0;
//(a)
double* dp = *i; // 非法，指针不能指向其他类型
//(b)
int *ip = i; //　非法，不能直接把int类型赋值给指针
//(c)
int *p = &i; // 正确，定义一个int型指针保存int变量i的地址。
````
#### Q2.22: 假设p是一个int型指针，请说明下述代码的含义。
````c++
if (p) // ...判断p指针是否为空
if (*p) // ...判断p指针所指向对象的值是否为true.
````
#### Q2.23: 给定指针p,你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。
#### A: 能。判断一个指针是否指向一个合法对象的依据是：
* 指针未初始化时
    * 如果是全局指针，则合法，编译器会默认初始化为空指针
    * 如果是函数体内的局部指针，则非法，指针行为不可知
* 指针类型和所指向类型的必须匹配
* 不能直接把一个对象直接赋值给指针对象
#### Q2.24: 在下面这段代码中为什么p合法而lp非法？
````c++
int i = 42;
void *p = &i; // void* 是特殊指针，可以存放任意对象的地址。
long *lp = &i;// 指针类型与对象类型不匹配。
````
#### Q2.25: 说明下列变量的类型和值
````c++
// ip是指向int型的指针，全局变量是为空指针，局部变量时未定义；
// i是int型变量，全局变量时为０，局部变量时为定义；
// r是变量i的引用
int* ip, i, &r = i;

// i是int型变量，全局变量时为０，局部变量时为定义；
// ip是int型的空指针
int i, *ip = 0;

// ip是int型的指针，ip2是int型变量
int* ip, ip2;
````
#### const修饰符
* const 对象必须初始化
* 编译器在编译过程中把用到const变量的地方都替换成对应的值。
* 默认情况下，const对象仅在文件内有效。当多个文件中出现了同名的const变量时，因每一个都必须被初始化，其实等同于在不同文件中分别定义了独立的变量。
* 如果想在多个文件间共享const变量，这声明和定义都必须添加`extern`关键字，这一点与普通变量不同:
````c++
// file_1.cc定义并初始化一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_2.cc
extern const int bufSize; // 不需要初始化，与file_1.cc中定义的bufSize是同一个。
````
#### Q2.2６: 下面哪些句子是合法的？如果有不合法的句子，请说明为什么？
````c++
const int buf; // 不合法，没有初始化，const变量必须初始化。
int cnt = 0; // 合法
const int sz = cnt; // 合法
++cnt; // 合法
++sz; // 不合法, const常量不可修改。
````
-----
#### const, 引用和指针
１　const和引用
* 常量引用可以引用常量和普通变量
````
// 对常量的引用
const int i = 0;
const int &ri = i;
// 对普通变量的引用
int j;
const int &rj = j;

// 非法操作:普通引用对常量的引用
int &ri = i;
````
2 const和指针
* 指针常量(指向常量)可以指向常量和普通变量，指针本身可变，但不可使用该指针改变所指向的变量。
````c++
// 指向常量
const int i;
const int *pi = &i;
// 指向普通变量
int j =;
const int *pj = &j;// 或者pi = &j.

//非法操作：普通指针指向常量
int *pi = i;
````
* 常量指针：　*在const之前，指针本身是常量不可变，但指向的变量可变
````c++
int errNumb = 0;
int *const curErr = &errNumb; // curErr将一直指向errNumb，不可重新指向其他变量
*curErr = 100; // 合法
const double pi = 3.14159;
const double *const pip = &pi; // pip是一个指向常量对象的常量指针
*pip = 2.72; // 错误
````
* 指针常量与常量指针的区别
````c++
int i = 0;
int k = 0;

const int *p = &i; // p所指向的对象是常量，p本身是普通对象，可改变。
*p = 10; // 错误，不允许通过p改变对象的值
p = &k; //　合法
int *const cp = &i; // cp所指向的是常量，可通过cp改变； 但p本身是常量不可改变。\
*cp = 100; // 合法,可通过cp改变普通对象的值.
cp = &k; // 错误，cp是常量，它本身不可修改。

const int *const cp2 = &i; // cp2所指向的是常量，本身也是常量
*cp2 = 100; // 错误，不可通过cp2修改对象的值。
cp2 = &k; // 错误，cp2本身是常量，不可修改。
````
-----
#### Q2.27: 下面的哪些初始化是合法的？请说明原因。
````c++
int i = -1, &r = 0; // 错误，不能定义一个字面值常量的非常量引用。
int *const p2 = &i2; // 合法，p2是指向int型变量的常量指针。
const int i = -1, &r = 0; // 合法，r是一个常量引用。
const int *const p3 = &i2; // 合法, p3是一个指向常量对象的常量指针
const int *p1 = &i2; // 合法，p1是一个指向常量对象的指针
const int &const r2; // 错误，没有常量对象的常量引用这个概念。
const int i2 = i, &r = i; // 合法，i2是int型常量，r是int型常量引用。
````
#### Q2.28: 说明下面的这些定义是什么意思，挑出其中不合法的。
````c++
int i, *const cp; //定义一个int型常量i和常量指针cp; cp不合法，必须初始化。
int *p1, *const p2; // 定义一个int型指针p1和常量指针p2; p2不合法，常量指针必须初始化。
const int ic, &r = ic; // 定义一个常量ic和它的常量引用ic; ic不合法，常量必须初始化。
const int *const p3; // 定义一个指向int型对象的常量指针; 不合法，常量指针必须初始化。
const int *p; // 定义一个指向int型常量对象的普通指针，不一定要初始化。
````
#### Q2.29: 假设已有上一个练习中定义的变量，则下面的哪些语句是合法的？请说明原因。
````c++
i = ic; //合法，将常量对象拷贝赋值给普通常量。
p1 = p3; // 不合法，p3指向的常量对象，而p1指向的是普通对象，不能赋值。
p1 = &ic; // 不合法，普通指针不能指向常量对象。
p3 = &ic; // 不合法，p3是常量指针，只能在定义时赋值，其他地方不能修改指针所保存对象的地址。
p2 = p1; // 不合法，p2是常量指针，不能在除定义以外的地方修改所保存对象的值
ic = *p3; // // 不合法，ic是一个常量，不能在定义以外的地方赋值。
````
#### Q2.30: 对于下面的这些语句，请说明对象被声明成了顶层const还是底层const?
````c++
const int v2 = 0; // 底层const
int v1 = v2; // 合法，拷贝赋值
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2 /*底层*/, *const p3 = &i /*顶层*/, &r2 = v2;/*底层*/
````
#### Q2.31:假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说明顶层const和底层const在每个例子中有何体现。
````c++
r1 = r2; // 合法，底层const可拷贝赋值到普通变量
p1 = p2; // 不合法，底层const的p2指针不能拷贝赋值到普通指针变量
p2 = p1; // 合法，非常量指针可以转换为指针常量
p1 = p3; // 合法，顶层const指针p3可以赋值给普通指针
p2 = p3; // 合法，顶层const不影响拷贝赋值，p2和p3都有底层const约束。
````
----
const与constexpr 修饰的区别：
````c++
const int sz = getSize(); // 合法,getSize()可以为普通函数。
constexpr int sz = size(); // size()的返回类型必须是constexpr.\

const int *p = nullptr; // p是一个指向整型常量的指针。
constexpr int *ｑ = nullptr; // q是一个指向整型的常量指针；constexpr只修饰指针，不限定所指的对象。
constexpr const int *p1 = nullptr; // 指向整型常量的常量指针。
//constexpr将变量定义为了顶层const.
````
----
#### `auto`在一条语句中声明多个变量时，因一条语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型必须都一样：
````c++
int i =0;
auto i = 0, *p = &i; // 正确：i是整型，ｐ是整型指针。
auto sz = 0, pi = 3.14; // 错误：sz和pi的类型不一致。
````
#### `auto`一般会忽略掉顶层const:
````c++
const int ci = 0, &cr = ci;
auto a = ci; // a是一个整数(ci的顶层const特效被忽略掉了)
const auto b = ci; // b是一个整型常量
auto &g = ci; // 整型常量引用(const特性被保留)
auto p = &ci; //指向整型常量的指针(const特性被保留) 
auto &h = 42; // 错误：不能为非常量引用h绑定到字面值。
const auto &j = 42; // 正确：可以为常量引用j绑定字面值。
````
#### Q2.33: 利用本节定义的变量，判断下列语句的运行结果。
````c++
a = 42; b = 42; c = 42; // 正确：都是给整型赋值.
d = 42; e= 42; g = 42; // 错误：d 和 e是指针类型，不能直接赋值整数；g是整型常量的引用，不能通过它修改变量的值。
````
#### Q2.35: 判断下列定义推断出的类型是什么，然后编写程序进行验证。
````c++
const int i = 42;
auto j = i; // int类型
const auto &k = i; // const int类型的引用
auto *p = &i; // const int*类型
const auto j2 = i, &k2 = i; // j2 是const int类型, k2是const int& 类型
````
#### A: 见2-35.cpp。

----
#### decltype和引用
* decltype返回表达式结果对应的类型:
````c++
int i = 42, *p = &i,  &ri = i;
decltype(r+0) b; // 正确：加法的结果是int, 因此b是一个未初始化的int型变量。
decltype(r) c; // 正确:c的类型是int型引用。
decltype(i) d; // 正确：ｄ是一个未初始化的int型变量。
decltype((i)) e; // 错误：e是int型引用，必须初始化。
decltype(*p) f; // 错误：指针解引用得到的是int型引用，必须初始化。
````
* `decltype((var))`的结果永远是引用，而`decltype(var)`的结果只有当`var`是引用变量或指针变量时才是引用。
----
#### Q2.36: 关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。
````c++
int a = 3, b = 4;
decltype(a) c = a; // c是int型
decltype((b)) d= a; // d是int型引用
++c;
++d;
// 程序结束时的值 a = 4, b = 4, c = 4, d = 4.
````
#### Q2.37: 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果i是int，则表达式`i = x`的类型是int&。根据这一特点，请指出下面的代码中每一个变量的类型和值。
````c++
int a = 3, b = 4; // int型
decltype(a) c = a; // c是int型，值为3
decltype(a = b) d = a; // d是ａ的int型引用,值为3; (a = b)只用来推断类型，不改变a的值。
````
#### Q2.38: 说明由decltype指定类型和由auto指定类型有何区别。请举出一个例子，decltype指定的类型与auto指定的类型一样；再举一个例子，decltype指定的类型与auto指定的类型不一样。
#### A:
* auto是根据初始值表达式来推断变量的类型
* decltype则是用表达式来推断类型，不用该表达式的值来初始化变量。
````c++
// 相同类型
int i = 0;
auto a = i; // a是int型
decltype(i) b; // b是一个int型
// 不同类型
int m = 0, &rm = m;
auto c = rm; // c是int型
decltype(rm) d; // d是int引用类型
````
#### Q2.39: 编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分号会发生什么情况？记录下相关信息，以后可能会有用。
````c++
struct Foo {} // 注意：没有分号。
````
#### A: 编译时报错：`error: expected ‘;’ after struct definition`
#### 2.40: 根据自己的理解写出Sales_data类，最好与书中的例子有所区别。
#### A:
````c++
struct Sales_data
{
    std::string bookName;
    unsigned int saledNum{0};
    double price{0.0};
};
````