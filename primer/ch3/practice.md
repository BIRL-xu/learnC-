#### 初始化string对象的方式：
````c++
std::string s1; // 默认初始化，s1是一个空字符串。
std::string s2(s1); // s2是s1的副本。
std::string s2 = s1; // 等价于s2(s1), s2是s1的副本。
std::string s3("value"); // s3是字面值"value"的副本，除了字面值最后的那个空字符外。、
std::string s3 = "value"; // 等价于s3("value")
std::string s4(n, 'c'); // 把s4初始化为由连续n个字符c组成的串。
std::string s４ = std::string(n, 'c'); // 等价于s4(n, 'c')．
````
#### 使用标准输入流输入字符串，即`std::cin >> s;`,string对象会自动忽略开头的空白（空格符、换行符和制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如输入是"    Hello World!    ",输出读入的是"Hello"。
````c++
// 循环读入字符，直至下一个空格
std::string word;
while(std::cin >> word)
{
    std::cout << word << std::endl; 
}
````
#### 使用`getline()`读入一整行，直至遇到换行符。
````c++
// 循环读入字符串，直至遇到换行符
std::string line;
while(getline(std::cin, line))
{
    std::cout << line << std::endl;
}
````
* `size()`函数返回值是`string::size_type`，是无符号数；因此，当表达式中有该函数时，不要使用int：`s.size() < n;`,如果n是int型的一个负数，则判定结果几乎始终为true,因为n会被转换成一个很大的无符号数。
* 字符串比较大小的规则：
    * 如果两个字符串长度不同，而且较短字符串的每个字符都与较长字符串对应位置上的字符相同，就说较短字符串小于较长字符串；
    * 如果两个字符串在某些**对应的位置**上不一致，则字符串比较的结果是两个字符串中**第一对相异字符**比较的结果；
````c++
std::string str = "Hello";
std::string phrase = "Hello World";
std::string slang = "Hiya";
// slang > phrase > str.
// 虽然slang最短，但它的第二个字符i比str和phrase的第二个字符都大
````
#### Q3.2: 编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入一个词。
#### A:见3-2.cpp．
#### Q3.3: 请说明string类的输入运算符和getline函数分别是如何处理空白字符的。
#### A: 
* string类的输入运算符会自动忽略语句起始的所有空白字符，然后将有效字符后的第一个空白字符当作该string对象的输入结束符。
* getline函数会把一行中的所有空白字符当作有效字符读取。
#### Q3.4: 编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不想读，输出比较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。
#### A: 见3-4.cpp。
#### Q3.5: 编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把多个字符串分隔开来。
#### A: 见3-5.cpp。
#### 访问string对象中的单个字符的两种方式：下标和迭代器。
#### Q3.6: 编写一段程序，使用范围for语句将字符串内的所有字符用X代替。
#### A: 见3-6.cpp。
#### Q3.7: 就上一题完成的程序而言，如果将循环控制变量的类型设为char将发生什么？先估计一下结果，然后实际编程验证。
#### A: 字符串保持不变。见3-7.cpp.
#### Q3.8:　分别用while循环和传统的for循环重写第一题的程序，你觉得哪种形式更好呢？为什么？
#### A: 见3-8.cpp。范围for循环更好，因为更加简洁，不用提前知道字符串的大小。
#### Q3.9: 下面的程序有何作用？它合法吗？如果不合法，为什么？
````c++
string s;
cout << s[0] << endl;
````
#### A: 作用是输出字符串的首字母，但是不合法，因为s是空字符串，无法获取首字母。
#### Q3.10: 编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。
#### A: 利用ispunct函数判断字符是否为标点符号，见3-10.cpp。
#### Q3.11: 下面的范围for语句合法吗？如果合法，c的类型是什么？
#### A:合法，c的类型是const char&。

----
#### vector初始化的方式
````c++
std::vector<T> v1; // v1是一个空vector,默认初始化
std::vector<T> v2(v1); // v2中包含v1所有元素的副本
std::vector<T> v2 = v1; // 等价于v2(v1)
std::vector<T> v3(n, val); // v3包含了n个重复的元素，每个元素的值都是val
std::vector<T> v4(n); // n个重复执行了值初始化的对象
std::vector<T> v5{a, b, c, ...};// 包含了初始值个数的元素，每个元素被赋予相应的初始值
std::vector<T> v5 = {a, b, c, ...}; // 等价于v5{a, b, c, ...}。
````
----
#### Q3.12: 下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果，对于不正确的，说明其错误的原因。
````c++
vector<vecotr<int>> ivec; // 正确: 创建一个空vector<int>的容器
vecotr<string> svec = ivec; // 错误: 类型不匹配
vector<string> svec(10, "null"); // 正确:　创建一个大小为１０，每个元素都为null的字符串型容器.
````
#### Q3.13: 下列的vector对象各包含多少个元素？这些元素的值分别是多少？
````c++
vector<int> v1; // 空vector
vector<int> v2(10); // 10个元素值都为０的容器。
vector<int> v3(10, 42); // 10个元素值都为42的容器。
vector<int> v4{10}; // １个元素值为10的容器。
vector<int> v5{10, 42}; // 2个元素值为10和42的容器。
vector<string> v6{10}; // 10个默认初始化的元素。
vector<string> v7{10, "hi"}; // 10个元素值都为hi的容器。
````
#### Q3.14: 编写一段程序，用cin读入一组整数并把它们存入一个vector对象。
#### A: 见3-14.cpp。
#### Q3.15: 改写上题的程序，不过这次读入的是字符串。
#### A:　见3-15.cpp。
#### Q3.16:编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来。检验你之前的回答是否正确，如果不对，回过头重新学习3.3.1节知道弄明白错在何处为止。、
#### A:　见3-16.cpp。
#### Q3.17: 从cin读入一组词并把它们存入一个vector对象，然后设法把所有词都改为大写形式。输出改变后的结果，每个词占一行。
#### A: 见3-17.cpp。
#### Q3.18:下面的程序合法吗？如果不合法，你准备如何修改？
````c++
vector<int> ivec;
ivec[0] = 42; // 不合法：ivec是空容器，不能使用下标访问。
// 修改为
ivec.push_back(42);
````
#### Q3.19: 如果想定义一个含有10个元素的vector对象，所有元素的值都是42,请列举出三种不同的实现方法。哪种方法更好呢？为什么？
````c++
// 循环拷贝初始化
vector<int> ivec;
for(int i = 0; i < 10; ++i)
{
    ivec.push_back(42);
}
// 列表初始化
vector<int> ivec{42, 42, 42, 42, 42, 42, 42, 42, 42, 42};
//重复执行拷贝初始化
vector<int> ivec(10, 42); // 更简洁。
````
#### Q3.20: 读入一组整数并把它们存入一个vector对象，将每对的和输出出来。改写你的程序，这次要求先输出第一个和最后一个元素的和，接着输出第２个和倒数第２个元素的和，以此类推。
#### A: 见3-20.cpp。

----
#### vector
* 如果vector对象是一个常量，只能使用`const_iterator`；　如果vector对象不是常量，那么既能使用`iterator`也能使用`const_iterator`。
* `begin`和`end`返回的具体类型由对象是否是常量决定.如果是常量，返回`const_iterator`;如果对象不是常量，返回`iterator`.
* `cbegin`和`cend`无论容器类型是不是常量都返回`const_iterator`。
* 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
*　两个迭代器相减得到它们之间的距离，即右侧的迭代器向前移动差值个位置后可追上左侧的迭代器。差值类型是`difference_type`的带符号整数。
----
#### Q3.21: 请使用迭代器重做3.3.3的第一个练习。
#### A:见3-21.cpp。
#### Q3.22: 修改之前那个输出text第一段的程序，首先把text的第一段全部改成大写形式，然后再输出它。
#### A: 见3-22.cpp。
#### Q3.23: 编写一段程序。创建一个含有10个整数的vector对象，然后使用迭代器将所有元素的值都变成原来的两倍。输出vector对象的内容，检验程序是否正确。
#### A: 见3-23.cpp。
#### Q3.24: 请使用迭代器重做3.3.3节的最后一个练习。
#### A: 见3-24.cpp。
#### Q3.25: 3.3.3节划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序并实现完全相同的功能。
#### A:　见3-25.cpp。
#### Q3.26: 在100页的二分搜索程序中，为什么用的是`mid = beg + (end - beg)/2`,而非`mid = (beg + end)/2`?
#### A: 因为`(end-beg)`是有符号的difference_type,可以进行除法运算；而`(beg+end)`还是迭代器类型，不能进行除法运算。

----
#### 字符数组
* 初始化
````c++
char a1[] = {'C', '+', '+'}; // 列表初始化，没有空字符。
char a2[] = {'C', '+', '+', '\0'}; // 列表初始化，含有空字符。
char a3[] = "C++"; // 字符串初始化字符数组，自动添加表示字符串结束的空字符\0。
const char a4[6] = "Daniel"; // 错误：没有空间存放空字符！常见错误！！！
char a5[] = a1; // 错误：不允许使用一个数组初始化另一个数组。
a2 = a1; // 错误：　不允许把一个数组直接赋值给另一个数组。
````
#### 数组的指针或数组额引文声明
````c++
int *ptrs[10]; // 从右往左读，ptr是含有10个整型指针的数组。
// 从括号往外读，Parray是一个指针，它指向int数组，大小是10。 因此，Parray是指向一个含有10个整数的指针。
int (*Parray)[10] = &arr; 
// 同理，arrRef引用一个含有10个整数的数组。
int (&arrRef)[10] = arr;
int *(&arry)[10] = ptrs; // arry是一个数组的引用，该数组包含10个整型指针。
````
----
#### Q3.27: 假设`txt_size`是一个无参数的函数，它的返回值是int。请回答下列哪个定义是非法的？为什么？
````c++
unsigned buf_size = 1024;
// (a)
int ia[buf_size]; // 合法
int ia[4*7-14]; // 合法
int ia[txt_size()]; // 合法，但是不能初始化.
char st[11] = "fundamental"; // 错误：没有空间存放空字符。
````
#### Q3.28: 下列数组中元素的值是什么？
````c++
string sa[10]; // 10个空字符
int ia[10]; // 10个零
int main()
{
    string sa2[10]; // 未定义
    int ia2[10]; // 未定义
}
````
#### Q3.29: 相比于vector来说，数组有哪些缺点，请列举一些。
#### A:
* 数组是固定大小的，程序运行中不能修改。
* 必须提前知道数组的大小
* 数组不允许拷贝和赋值，即不能将数组的内容拷贝到其他数组作为其初始值，但是vector可以
* 数组使用的过程，容易产生数组越界，而相对于vector则可以使用较多的机制来控制，例如使用迭代器
#### Q3.30: 指出下面代码中的索引错误。
````c++
constexpr size_t array_size = 10;
int ia[array_size];
for(size_t ix = 1; ix <= array_size; ++ix)  // 当访问ia[array_size]元素时数组溢出。
{
    ia[ix] = ix;
}
````
#### Q3.31: 编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。
#### A: 见3-31.cpp。
#### Q3.32: 将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实现类似的功能。
#### A: vector可以直接赋值，数组需要每个元素单独赋值。见3-32.cpp。

----
#### `auto`和`decltype`在推断数组名称时存在区别：
````c++
int ia[5] = {0, 1, 2, 3, 4};
auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素；等价于auto ia2(&ia[0])。
decltype(ia) ia3; // ia3是由5个整数构成的数组。
````
----
#### 获取数组的尾后指针:
* 就像vector的end返回的指针一样。假设arr是含有９个整数的数组，则尾指针可为`int *e = &arr[10]`;但是该指针不能用于解引用和递增，仅是为了想vector迭代器一样操作数组。
* **推荐做法**：使用标准库中的`begin()`和`end()`函数获取数组的首指针和尾后指针，这两个函数定义在`iterator`头文件中：
````c++
int ia[] = {1, 2, 3, 4, 5};
int *beg = begin(ia); // 指向ia首元素的指针
int *last = end(ia); // 指向ia尾元素的下一位置的指针
````
#### 当用数组指针做加法运算时，指针最多可指向尾元素的下一位置，即**首指针+数组长度**，超过该范围就会溢出。
#### 两指针相减的结果的类型是带符号的`ptrdiff_t`，定义在`cstddef`头文件中。
#### 下标和指针: 获取数组指针后，可以通过指针加下标的形式访问数组,这种操作方式**p的值不会改变**：
````c++
int *p = &ia[2]; // p现在指向索引为２的元素
int j = p[1]; // 等价于*(p+1)，现在指向ia[3]表示的那个元素
int k = p[-2]; // 等价于*(p-2),　现在指向ia[0]所表示的那个元素。
````
#### Q3.34: 假定指针p1和p2指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？
````c++
p1 += p2 - p1; // 将指针p1移动到p2处。当p1是常量指针时非法！！！
````
#### Q3.35: 编写一段程序，利用指针将数组的元素置０。
#### A: 见3-35.cpp。
#### Q3.36: 编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。
#### A: 两个数组或vector对象是否相等的前提是非空和大小一样。见3-36.cpp。
