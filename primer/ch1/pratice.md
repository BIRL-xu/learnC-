### Q1.1: 查阅你使用的编译器的文档，确定它所使用的文件命名约定。编译并运行第2页的main程序。
### A: 
* 我使用的系统是Ubuntu16.04,在终端使用命令`g++ --version`可以查看当前正在使用的编译器版本。我的结果显示为`g++ (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609`。
* 编译程序：
```c++
mkdir build && cd build
g++ -o 1-1 ../1-1.cpp
./1-1 && echo "success"
// 正常结果会输出success
```
### Q1.2: 改写程序，让main函数返回-1。返回-1通常被当作程序错误的表示。重新编译并运行你的程序，观察你的系统如何处理main返回的错误标识符。
### A:
```c++
// execute these commands under build directory
g++ -o 1-2 ../1-1.cpp
./1-2 && echo "success"
// 正常结果不会输出任何东西，因为./1-2执行失败，导致不会执行echo "success"
```
#### 扩展知识，Linux下获取main函数返回值的方法：
* 在终端执行程序
* 使用命令`echo $?`捕获并打印结果
```c++
./1-1
echo $?
// 输出0
./1-2
echo $?
// 输出255
```
* 论C/C++，从main函数中返回的效果都相当于调用exit函数，main函数的返回值会作为传给exit的函数。而exit或者main函数中的return, 只能使用0~255之间的值。 由于 -1 的unsigned值就是255，因此在命令行显示的错误码为255.
系统用8bits的无符号数标识退出状态，所以退出的状态值为0至255。
### Q1.3: 编写程序，在标准输出上打印Hello, World。

### Q1.4: 我们的程序使用假发运算符+来将两个数想家。编写程序使用乘法运算符*来打印两个数的积。
### A: `std::cin >> v1 >> v2;`,使用空格将两个输入分隔开，程序会分别赋值给v1和v2。
### Q1.5: 重写程序，将每个运算对象的打印操作放在独立的语句中。
### A: 使用std::cout单独打印每个运算对象，打印结束不加换行符，这样多行std::cout会打印为一行。
### Q1.6: 解释下面程序片段是否合法：
```
std::cout << "The sum of " << v1;
          << " and " << v2;
          << " is " << v1 + v2 << std::endl;
```
### A: 第1行合法，但第2和3行不合法。因为第1行的输出流已结束，第2和3行无法输出。正确代码为：
```
std::cout << "The sum of " << v1;
std::cout << " and " << v2;
std::cout << " is " << v1 + v2 << std::endl;
```
### Q1.7: 编译一个包含不正确的嵌套注释的程序，观察编译器返回的错误信息。
错误代码：
```
/*
 * 注释对/* */不能嵌套。
 * “不能嵌套”几个字会被认为是源码，
 * 像剩余程序一样处理。
 *
 */

int main()
{
	return 0;
}
```
### A: 编译器会自动匹配与`/*`最近的一个`*/`作为注释界定符的结束符。`*/`之后的所有注释语句会被当作源码编译，所以编译器会报乱码错误。并且会提示最后一个界定符`*/`缺少匹配的起始符`/*`。
### Q1.8: 指出下列哪些输出语句是合法的（如果有的话）：
```c++
std::cout << "/*";
std::cout << "*/";
std::cout << /* "*/" */;
std::cout << /* "*/" /* "/*" */;
```
### A:
```c++
std::cout << "/*"; // 合法，输出/*。
std::cout << "*/"; // 合法，输出*/。
std::cout << /* "*/" */; // 不合法，第一个双引号被注释掉，导致二个双引号匹配失败，编译报错。可改为std::cout << /* "*/" */ “;
std::cout << /* "*/" /* "/*" */; // 合法，输出 /* 。
```
### Q1.9: 编写程序，使用while循环将50到100的整数相加。
### A: 见1-9.cpp。
### Q1.10: 除了++运算符将运算对象的值增加1之外，还有一个递减运算符--实现将值减1/。编写程序，使用递减运算符在循环中按递减顺序打印出10到0之间的整数。
### A: 见1-10.cpp。
### Q1.11: 编写程序，提示用户输入两个整数，打印出这两个整数所制定的范围内的所有整数。
### A: 使用std::cin输入整数，见1-11.cpp。
### Q1.12: 下面的for循环完成了什么功能？sum的终值是多少？
```c++
int sum = 0;
for (int i = -100; i <= 100; ++i)
    sum += i;
```
### A: 这段代码实现了[-100, 100]内所有整数求和的功能，显然，最终结果为0.
### Q1.14: 对比for循环和while循环，两种形式的优缺点是什么？
### A: 
1、在for循环中，循环控制变量的初始化和修改都放在语句头部分，形式较简洁，且特别适用于循环次数已知的情况。

2、在while循环中，循环控制变量的初始化一般放在while语句之前，循环控制变量的修改一般放在循环体中，形式上不如for语句简洁，但它比较适用于循环次数不易预知的情况（用某一条件控制循环）。

3、两种形式各有优点，但它们在功能上是等价的，可以相互转换。

### Q1.20: 在网站https://www.informit.com/title/0321714113上，第1章的代码目录中包含了头文件Sales_item.h.将它拷贝到你自己的工作目录中。用它编写一个程序，读取一组书籍销售记录，将每条记录打印到标准输出上。
### A: 见1-20.cpp
### Q1.21: 编写程序，读取两个ISBN相同的Sales_item对象，输出他们的和。
### A: 见1-21.cpp
### Q1.22: 编写程序，读取多个具有相同ISBN的销售记录，输出所有记录的和。
### A: 见1-22.cpp，值得注意的是，该程序要求相同ISBN编码的销售记录必须连续，不能统计间隔重复的销售记录。
### Q1.23 & Q1.24: 编写程序，读取多条销售记录，并统计每个ISBN(每本书)有几条销售记录。
### A: 见1-23.cpp。
### Q1.24: 借助网站上的Sales_item.h头文件，编译并运行本节给出的书店程序。
### A: 见1-24.cpp。

