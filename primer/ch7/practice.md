 #### this指针
 * 默认情况下this是一个常量指针，它的类型是`classname *const`，所以，默认情况下,this指针不能访问常量对象(因为访问常量对象需要指向常量的指针)；
 * 常量成员函数：在成员函数的形参列表后面加`const`用于声明在调用该函数时this指针被定义为了指向常量的指针，即`const classname *const this;`;
 #### Q7.2: 曾在2.6.2节的练习中编写了一个Sanles_data类，请向这个类添加combine和isbn成员。
 #### A:见7-2.h和7-2.cpp。
 #### Q7.3: 修改7.1.1节的交易处理程序，令其使用这些成员。
 #### A:见7-3.h和7-3.cpp。
 #### Q7.4: 编写一个名为Person的类，使其表示人员的姓名和住址。使用string对象存放这些元素，接下来的练习将不断充实这个类的其他特征。
 #### A: 见person.h。
 #### Q7.5: 在你的Person类中提供一些操作使其能够返回姓名和住址。这些函数是否应该是const的呢？请解释原因。
 #### A:见person.h和person.cpp。这些函数应该是const的，因为只是查看姓名和地址，不需要修改。
 * 如果非成员函数是类接口的组成部分，则这些函数的声明建议与类在同一个头文件内。
 #### Q7.7: 使用这些新函数重写7.1.2节练习中的交易处理程序。
 #### A: 见7-7.h和7-7.cpp。
 #### Q7.8: 为什么read函数将其Sales_data参数定义成普通的引用，而print将其参数定义成常量引用？
 #### A:因为read函数需要将输入流的数据写入数据成员，而print函数只访问数据成员，不需要修改。
 #### Q7.9: 对于7.1.2节练习中的代码，添加读取和打印Person对象的操作。
 #### A: 见person.h和person.cpp。
 * 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全部被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。
 #### Q7.11&Q7.12: 在你的Sales_data类中添加构造函数，然后编写一段程序令其用到每个构造函数。
 #### A: 见7-11.h和7-11.cpp。
 #### Q7.13:使用istream构造函数重写第229页的程序。
 #### A:见7-13.h和7-13.cpp。
 #### Q7.15:为你的Person类添加正确的构造函数.
 
 ----
 #### 类对象拷贝的几种情况：
 * 初始化
 * 以值的方式传递(赋值、传参)
 * 返回类对象
 #### 访问控制与封装
 * `struct`关键字的默认访问权限是**public**,`class`关键字的默认访问权限是**private**
 #### 友元
 * 类允许其他类或者函数访问它的非公有成员：令其他类或者函数成为它的友元；
 * 在类内部的其他类或函数的声明前加关键字`friend`可声明为友元: 
    * 友元类或函数自身的声明
    * 友元类或函数在被访问类内部以关键字`friend`开头再次进行声明；
 ----
 #### Q7.18: 封装是何含义？它有什么用处？
 #### A:封装就是使用访问说明符限定数据成员和成员函数的访问权限，能够强制用户只能通过类开放的接口访问类，而不能直接访问类的实现细节。
 #### Q7.19: 在你的Person类中，你将把哪些成员声明成publick的？哪些成员声明成privat的？解释你这样左的原因。
 #### A: 将数据成员声明为private以达到保护数据的目的，避免外部程序直接修改数据成员。将访问数据成员的借口和构造函数声明为public,给外部程序访问该类。
 ````c++
class Person{
public:
    Person() = default;
    Person(const std::string &id, const std::string& addr) :
           name(id), address(addr){}
    Person(std::istream &is)
    {
        is >> name >> address;
    }

    std::string getName() const {return name;} // 返回值不能是普通引用类型，因为常量函数体内的变量被隐式声明为了常量；
//    const std::string &getName() const {return name;} // 正确
    std::string getAddress() const {return address;}
//    const std::string &getAddress() const {return address;} // 正确
private:
    std::string name;
    std::string address;
};
````
#### Q7.20: 友元在什么时候有用？请分别列举出使用友元的利弊。
#### A: 友元在外部程序想要直接访问目标类非共有成员时可用；友元为用户提供更多的接口访问目标类，但是会破坏目标类的封装。
#### Q7.21: 修改你的Sales_daa类使其隐藏实现的细节。你之前编写的关于Sales_data操作的程序应该继续使用，借助类的新定义重写编译程序，确保其正常工作。
#### A:见7-21.h和7-21.cpp。

----

###　类的一些特性
#### 类型成员
* 使用`typedef`或`using`定义类型成员
* 类型成员必须先定义后使用，因此，类型成员通常在类开始处定义；
#### 可变数据成员
* mutable数据成员丢失了const属性，常量成员函数和非常量成员函数都能修改它的值。
* mutable主要用来修饰常量成员函数想要修改的那些变量；
#### 类内初始值
* 当我们在类内部为另一个类提供初始值时，必须以符号=或者花括号表示。
----

#### Q7.23 & 7.24: 编写你自己的Screen类。
#### A: 见7-23.h
 